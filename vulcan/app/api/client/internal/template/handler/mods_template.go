package handler

import (
	"bytes"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/go-pantheon/fabrica-util/camelcase"
	"github.com/go-pantheon/roma/vulcan/pkg/compilers"
)

var modTemplate = `
{{- /* delete empty line */ -}}
// Code generated by gen-api-client. DO NOT EDIT.

package handler

import (
	"context"

	"{{.Org}}/fabrica-util/errors"
	"{{.Org}}/fabrica-kit/xerrors"
	climsg "{{.Project}}/gen/api/client/message"
	cliseq "{{.Project}}/gen/api/client/sequence"
	"{{.Project}}/gen/app/codec"
	"{{.Project}}/gen/app/{{.LowerGroup}}/service"
	"google.golang.org/protobuf/proto"
)

func handle{{.UpperCamelMod}}(ctx context.Context, s *service.{{.Group}}Services, mod, seq int32, obj int64, in []byte) ([]byte, error) {
	cs, err := codec.UnmarshalCS{{.UpperCamelMod}}(seq, in)
	if err != nil {
		return nil, err
	}

	var (
		sc  proto.Message
	)

	{{- $upperMod := .UpperCamelMod}}
	switch cliseq.{{$upperMod}}Seq(seq) {
	{{- range .Apis }}
	{{- if .CS }}

	// {{.Comment}}
	case cliseq.{{$upperMod}}Seq_{{.UpperCamelName}}:
		sc, err = s.{{$upperMod}}.{{.UpperCamelName}}(ctx, cs.(*climsg.{{.CS}}))
	{{- end }}
	{{- end }}

	default:
		return nil, errors.WithMessagef(xerrors.ErrHandlerNotFound, "invalid seq. mod=%s seq=%d", "{{.UpperCamelMod}}", seq)
	}

	out, err0 := New{{.Group}}Response(mod, seq, obj, sc)
	if err0 != nil {
		return nil, errors.Wrapf(err0, "proto marshal failed. mod=%s seq=%d", "{{.UpperCamelMod}}", seq)
	}
	return out, err
}
`

type ModService struct {
	Org           string
	Project       string
	UpperCamelMod string

	Group      string
	LowerGroup string

	Apis []*compilers.Api
}

func NewModService(project string, mod compilers.ModType, c *compilers.SeqCompiler) *ModService {
	s := &ModService{
		Project: project,
	}

	s.Org = filepath.Clean(strings.Replace(s.Project, filepath.Base(s.Project), "", 1))
	s.UpperCamelMod = camelcase.ToUpperCamel(string(mod))
	s.Group = camelcase.ToUpperCamel(string(c.Group))
	s.LowerGroup = camelcase.ToLowerCamel(string(c.Group))
	s.Apis = c.Apis

	return s
}

func (s *ModService) Execute() ([]byte, error) {
	buf := new(bytes.Buffer)

	tmpl, err := template.New("handler_mods").Parse(modTemplate)
	if err != nil {
		return nil, err
	}

	if err = tmpl.Execute(buf, s); err != nil {
		return nil, err
	}

	return buf.Bytes(), nil
}
