package handler

import (
	"bytes"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/go-pantheon/fabrica-util/camelcase"
	"github.com/go-pantheon/roma/vulcan/pkg/compilers"
)

var respTemplate = `
{{- /* delete empty line */ -}}
// Code generated by gen-api-client. DO NOT EDIT.

package handler

import (
	"sync"

	"{{.Org}}/fabrica-util/errors"
	intrav1 "{{.Project}}/gen/api/server/{{.LowerGroup}}/intra/v1"
	"google.golang.org/protobuf/proto"
)

// TakeProto{{.UpperGroup}}TunnelResponse takes a proto message from pool and must call Put{{.UpperGroup}}ResponseProto to put it back.
func TakeProto{{.UpperGroup}}TunnelResponse(index, mod, seq int32, Obj int64, in proto.Message) (ret *intrav1.TunnelResponse, err error) {
	data, err := proto.Marshal(in)
	if err != nil {
		return nil, errors.Wrapf(err, "proto marshal failed. mod=%d seq=%d obj=%d", mod, seq, Obj)
	}

	return TakeBytes{{.UpperGroup}}TunnelResponse(index, mod, seq, Obj, data), nil
}

// TakeBytes{{.UpperGroup}}TunnelResponse takes a proto message from pool and must call Put{{.UpperGroup}}TunnelResponse to put it back.
func TakeBytes{{.UpperGroup}}TunnelResponse(index, mod, seq int32, Obj int64, data []byte) (p *intrav1.TunnelResponse) {
	p = get{{.UpperGroup}}TunnelResponse()

	p.Index = index
	p.Mod = mod
	p.Seq = seq
	p.Obj = Obj
	p.Data = data

	return p
}

func Put{{.UpperGroup}}TunnelResponse(p *intrav1.TunnelResponse) {
	put{{.UpperGroup}}TunnelResponse(p)
}

var {{.LowerGroup}}TunnelResponsePool = sync.Pool{
	New: func() interface{} {
		return &intrav1.TunnelResponse{}
	},
}

func get{{.UpperGroup}}TunnelResponse() *intrav1.TunnelResponse {
	return {{.LowerGroup}}TunnelResponsePool.Get().(*intrav1.TunnelResponse)
}

func put{{.UpperGroup}}TunnelResponse(p *intrav1.TunnelResponse) {
  if p == nil {
		return
	}

	p.Reset()
	{{.LowerGroup}}TunnelResponsePool.Put(p)
}

`

type RespService struct {
	Org        string
	Project    string
	UpperGroup string
	LowerGroup string
}

func NewRespService(project string, c *compilers.ModsCompiler) *RespService {
	s := &RespService{
		Project:    project,
		UpperGroup: camelcase.ToUpperCamel(string(c.Group)),
		LowerGroup: camelcase.ToLowerCamel(string(c.Group)),
	}

	s.Org = filepath.Clean(strings.Replace(s.Project, filepath.Base(s.Project), "", 1))

	return s
}

func (s *RespService) Execute() ([]byte, error) {
	buf := new(bytes.Buffer)

	tmpl, err := template.New("handler_response").Parse(respTemplate)
	if err != nil {
		return nil, err
	}

	if err = tmpl.Execute(buf, s); err != nil {
		return nil, err
	}

	return buf.Bytes(), nil
}
