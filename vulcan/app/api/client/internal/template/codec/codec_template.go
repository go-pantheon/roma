package codec

import (
	"bytes"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/go-pantheon/fabrica-util/camelcase"
	"github.com/go-pantheon/roma/vulcan/pkg/compilers"
)

var codecTemplate = `
{{- /* delete empty line */ -}}
// Code generated by gen-api-client. DO NOT EDIT.

package codec

import (
	"{{.Org}}/fabrica-util/errors"
	climod "{{.Project}}/gen/api/client/module"
	clipkt "{{.Project}}/gen/api/client/packet"
	"google.golang.org/protobuf/proto"
)

func UnmarshalCS(mod, seq int32, bytes []byte) (cs proto.Message, err error) {
	switch climod.ModuleID(mod) {
	{{- range .Mods }}
	case climod.ModuleID_{{.UpperCamel}}:
		return UnmarshalCS{{.UpperCamel}}(seq, bytes)
	{{- end }}
	default:
		return nil, errors.Errorf("module not found. mod=%d", mod)
	}
}

func UnmarshalSCPacket(p *clipkt.Packet) (sc proto.Message, err error) {
	if p == nil {
		return nil, errors.Errorf("packet is nil")
	}

	return UnmarshalSC(p.Mod, p.Seq, p.Data)
}

func UnmarshalSC(mod, seq int32, bytes []byte) (sc proto.Message, err error) {
	switch climod.ModuleID(mod) {
	{{- range .Mods }}
	case climod.ModuleID_{{.UpperCamel}}:
		return UnmarshalSC{{.UpperCamel}}(seq, bytes)
	{{- end }}
	default:
		return nil, errors.Errorf("mod not found. mod=%d", mod)
	}
}

func IsPushSC(mod climod.ModuleID, seq int32) bool {
	switch mod {
	{{- range .Mods }}
	case climod.ModuleID_{{.UpperCamel}}:
		return IsPushSC{{.UpperCamel}}(seq)
	{{- end }}
	default:
		return false
	}
}
`

type Service struct {
	Org     string
	Project string
	Mods    []*Mod
}

type Mod struct {
	UpperCamel string
	LowerCamel string
	UnderScore string
}

func NewService(project string, mcs []*compilers.ModsCompiler) *Service {
	s := &Service{
		Project: project,
	}

	for _, c := range mcs {
		for _, mod := range c.Mods {
			modStr := string(mod)
			s.Mods = append(s.Mods, &Mod{
				LowerCamel: modStr,
				UpperCamel: camelcase.ToUpperCamel(modStr),
				UnderScore: strings.ToUpper(camelcase.ToUnderScore(modStr)),
			})
		}
	}

	s.Org = filepath.Clean(strings.Replace(s.Project, filepath.Base(s.Project), "", 1))

	return s
}

func (s *Service) Execute() ([]byte, error) {
	buf := new(bytes.Buffer)

	tmpl, err := template.New("codec").Parse(codecTemplate)
	if err != nil {
		return nil, err
	}

	if err = tmpl.Execute(buf, s); err != nil {
		return nil, err
	}

	return buf.Bytes(), nil
}
