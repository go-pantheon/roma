package codec

import (
	"bytes"
	"strings"
	"text/template"

	"github.com/go-pantheon/roma/vulcan/pkg/compilers"
	"github.com/go-pantheon/fabrica-util/camelcase"
)

var codecTemplate = `
{{- /* delete empty line */ -}}
// Code generated by gen-api. DO NOT EDIT.

package codec

import (
	"github.com/pkg/errors"
	"google.golang.org/protobuf/proto"
	climod "{{.Project}}/roma/gen/api/client/module"
	clipkt "{{.Project}}/roma/gen/api/client/packet"
)

func UnmarshalCS(mod, seq int32, bytes []byte) (cs proto.Message, err error) {
	switch climod.ModuleID(mod) {
	{{- range .Mods }}
	case climod.ModuleID_{{.UpperCamel}}:
		return UnmarshalCS{{.UpperCamel}}(seq, bytes)
	{{- end }}
	default:
		err = errors.Errorf("module not found. mod=%d", mod)
		return
	}
}

func UnmarshalSC(in *clipkt.Packet) (sc proto.Message, err error) {
    if in == nil {
		err = errors.Errorf("packet is nil")
		return
	}

	switch climod.ModuleID(in.Mod) {
	{{- range .Mods }}
	case climod.ModuleID_{{.UpperCamel}}:
		return UnmarshalSC{{.UpperCamel}}(in.Seq, in.Data)
	{{- end }}
	default:
		err = errors.Errorf("module not found. mod=%d", in.Mod)
		return
	}
}

func IsPushSC(mod climod.ModuleID, seq int32) bool {
	switch mod {
	{{- range .Mods }}
	case climod.ModuleID_{{.UpperCamel}}:
		return IsPushSC{{.UpperCamel}}(seq)
	{{- end }}
	default:
		return false
	}
}
`

type Service struct {
	Project string
	Mods    []*Mod
}

type Mod struct {
	UpperCamel string
	LowerCamel string
	UnderScore string
}

func NewService(project string, mcs []*compilers.ModsCompiler) *Service {
	s := &Service{
		Project: project,
	}
	for _, c := range mcs {
		for _, mod := range c.Mods {
			modStr := string(mod)
			s.Mods = append(s.Mods, &Mod{
				LowerCamel: modStr,
				UpperCamel: camelcase.ToUpperCamel(modStr),
				UnderScore: strings.ToUpper(camelcase.ToUnderScore(modStr)),
			})
		}
	}
	return s
}

func (s *Service) Execute() ([]byte, error) {
	buf := new(bytes.Buffer)

	tmpl, err := template.New("codec").Parse(codecTemplate)
	if err != nil {
		return nil, err
	}
	if err = tmpl.Execute(buf, s); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
