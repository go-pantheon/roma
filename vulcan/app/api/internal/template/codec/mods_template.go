package codec

import (
	"bytes"
	"text/template"

	"github.com/go-pantheon/roma/vulcan/pkg/compilers"
	"github.com/go-pantheon/fabrica-util/camelcase"
)

var modTemplate = `
{{- /* delete empty line */ -}}
// Code generated by gen-api. DO NOT EDIT.

package codec

import (
	"strings"

	"github.com/pkg/errors"
	"google.golang.org/protobuf/proto"
	climsg "{{.Project}}/roma/gen/api/client/message"
	cliseq "{{.Project}}/roma/gen/api/client/sequence"
)
{{- $lowerCamelMod := .LowerCamelMod}}
{{- $upperCamelMod := .UpperCamelMod}}

func UnmarshalCS{{$upperCamelMod}}(seq int32, data []byte) (p proto.Message, err error) {
	switch cliseq.{{$upperCamelMod}}Seq(seq) {
	{{- range .Apis }}
	{{- if .CS }}
	// {{.Comment}}
	case cliseq.{{$upperCamelMod}}Seq_{{.UpperCamelName}}:
		pp := &climsg.{{.CS}}{}
		err = proto.Unmarshal(data, pp)
		p = pp
	{{- end }}
	{{- end }}

	default:
		err = errors.Errorf("Unmarshal CS{{$upperCamelMod}} faild. sequence not found. seq=%d", seq)
		return
	}

	if err != nil {
		return nil, errors.Wrapf(err, "Unmarshal CS{{$upperCamelMod}} faild. seq=%d", seq)
	}
	return
}

func UnmarshalSC{{$upperCamelMod}}(seq int32, data []byte) (p proto.Message, err error) {
	switch cliseq.{{$upperCamelMod}}Seq(seq) {

	{{- range .Apis }}
	{{- if .SC }}
	// {{.Comment}}
	case cliseq.{{$upperCamelMod}}Seq_{{.UpperCamelName}}:
		pp := &climsg.{{.SC}}{}
		err = proto.Unmarshal(data, pp)
		p = pp
	{{- end }}
	{{- end }}

	default:
		err = errors.Errorf("Unmarshal SC{{$upperCamelMod}} faild. sequence not found. seq=%d", seq)
		return
	}

	if err != nil {
		return nil, errors.Wrapf(err, "Unmarshal SC{{$upperCamelMod}} faild. seq=%d", seq)
	}
	return
}

func IsPushSC{{$upperCamelMod}}(seq int32) bool {
	name := cliseq.{{$upperCamelMod}}Seq_name[seq]
	return strings.Index(name, "Push_") == 0
}
`

type ModService struct {
	Project string

	UpperCamelMod string
	LowerCamelMod string

	Apis []*compilers.Api
}

func NewModService(project string, mod compilers.ModType, c *compilers.SeqCompiler) *ModService {
	s := &ModService{
		Project: project,
	}
	s.LowerCamelMod = string(mod)
	s.UpperCamelMod = camelcase.ToUpperCamel(string(mod))
	s.Apis = c.Apis
	return s
}

func (s *ModService) Execute() ([]byte, error) {
	buf := new(bytes.Buffer)

	tmpl, err := template.New("codec_mods").Parse(modTemplate)
	if err != nil {
		return nil, err
	}
	if err = tmpl.Execute(buf, s); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
