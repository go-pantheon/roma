package data

import (
	"bytes"
	"text/template"

	"github.com/go-pantheon/fabrica-util/camelcase"
	"github.com/go-pantheon/roma/vulcan/app/gamedata/internal/parser/field"
	"github.com/go-pantheon/roma/vulcan/app/gamedata/internal/parser/sheet"
	"github.com/pkg/errors"
)

var dataTemplate = `
{{- /* delete empty line */ -}}
// Code generated by gen-datas. DO NOT EDIT.

package gamedata

import (
	{{.Package}}_base "github.com/go-pantheon/roma/gen/gamedata/base/{{.Package}}"
	"github.com/pkg/errors"
)

var _ = errors.New("import holding")

{{if .IsTable}}
// {{.DataStruct}}s {{.TablePath}}
type {{.DataStruct}}s struct {
	List []*{{.DataStruct}}
	Map  map[int64]*{{.DataStruct}}
}
{{ end }}	

// {{.DataStruct}}Gen {{.TablePath}}
type {{.DataStruct}}Gen struct {
	*{{.Package}}_base.{{.BaseStruct}}Gen

	{{if .HasSubData}}
	SubDataList []*{{.SubDataStruct}}Gen
	SubDataMap  map[int64]*{{.SubDataStruct}}Gen
	{{- end}}

	{{range .JoinedStructs}}
	{{.FieldName}}Data *{{.DataStruct}}Data
	{{- end}}
	{{range .JoinedListStructs}}
	{{.FieldName}}DataList []*{{.DataStruct}}Data
	{{- end}}
	{{range .JoinedMapStructs}}
	{{.FieldName}}DataMap map[int64]*{{.DataStruct}}Data
	{{end}}
	{{range .GameStructs}}
	{{.FieldName}}{{.DataStruct}} *{{.DataStruct}}
	{{- end}}
	{{- range .GameStructLists}}
	{{.FieldName}}{{.DataStruct}}List []*{{.DataStruct}}
	{{- end}}
}

{{ if .HasSubData}}
type {{.SubDataStruct}}Gen struct {
	*{{.Package}}_base.{{.SubBaseStruct}}Gen

	{{range .JoinedSubStructs}}
	{{.FieldName}}Data *{{.DataStruct}}Data
	{{- end}}
	{{range .JoinedListSubStructs}}
	{{.FieldName}}DataList []*{{.DataStruct}}Data
	{{- end}}
	{{range .JoinedMapSubStructs}}
	{{.FieldName}}DataMap map[int64]*{{.DataStruct}}Data
	{{end}}
	{{range .SubGameStructs}}
	{{.FieldName}}{{.DataStruct}} *{{.DataStruct}}
	{{- end}}
	{{- range .SubGameStructLists}}	
	{{.FieldName}}{{.DataStruct}}List []*{{.DataStruct}}
	{{- end}}
}
{{- end }}

{{if .IsTable}}
func new{{.DataStruct}}s(bases *{{.Package}}_base.{{.BaseStruct}}Gens) (*{{.DataStruct}}s, error) {
	ds := &{{.DataStruct}}s{
		List: make([]*{{.DataStruct}}, 0, len(bases.DataBases)),
		Map:  make(map[int64]*{{.DataStruct}}, len(bases.DataBases)),
	}
	for _, base := range bases.DataBases {
		d, err := new{{.DataStruct}}(base)
		if err != nil {
			return nil, err
		}
		ds.List = append(ds.List, d)
		ds.Map[d.ID] = d
	}
	return ds, nil
}
{{ end }}

func new{{.DataStruct}}(base *{{.Package}}_base.{{.BaseStruct}}Gen) (d *{{.DataStruct}}, err error) {
	d = &{{.DataStruct}}{}

	d.{{.DataStruct}}Gen, err = new{{.DataStruct}}Gen(base)
	if err != nil {
		return nil, err
	}
	return d, nil
}

func new{{.DataStruct}}Gen(base *{{.Package}}_base.{{.BaseStruct}}Gen) (d *{{.DataStruct}}Gen, err error) {
	d = &{{.DataStruct}}Gen{
		{{.BaseStruct}}Gen: base,
		{{if .HasSubData}}
		SubDataList: make([]*{{.SubDataStruct}}Gen, 0, len(base.SubDatas)),
		SubDataMap:  make(map[int64]*{{.SubDataStruct}}Gen, len(base.SubDatas)),
		{{- end}}
		{{range .JoinedMapStructs}}
		{{.FieldName}}DataMap: make(map[int64]*{{.DataStruct}}Data, len(d.{{.FieldName}})),
		{{- end}}
	}

	{{if .HasSubData}}
	for _, o := range base.SubDatas {
		sd, err := new{{.SubDataStruct}}Gen(o)
		if err != nil {
			return nil, err
		}
		d.SubDataList = append(d.SubDataList, sd)
		d.SubDataMap[sd.{{.SubIdField}}] = sd
	}
	{{- end}}
	
	return d, nil
}

{{if .HasSubData}}
func new{{.SubDataStruct}}Gen(base *{{.Package}}_base.{{.SubBaseStruct}}Gen) (d *{{.SubDataStruct}}Gen, err error) {
	d = &{{.SubDataStruct}}Gen{
		{{.SubBaseStruct}}Gen: base,
		{{range .JoinedMapSubStructs}}
		{{.FieldName}}DataMap: make(map[int64]*{{.DataStruct}}Data, len(d.{{.FieldName}})),
		{{- end}}
	}
	return d, nil
}
{{- end }}

{{if .IsTable}}
func (ds *{{.DataStruct}}s) init() error {
	for _, d := range ds.List {
		if err := d.init(); err != nil {
			return err
		}
	}
	return nil
}

func (ds *{{.DataStruct}}s) build() {
	for _, d := range ds.List {
		d.build()
	}
}
{{ end }}

func (d *{{.DataStruct}}Gen) build() {
	{{- range .JoinedStructs}}
	d.{{.FieldName}}Data = Get{{.DataStruct}}Data(d.{{.FieldName}})
	{{end}}
	{{- range .JoinedListStructs}}
	for _, id := range d.{{.FieldName}} {
		d.{{.FieldName}}DataList = append(d.{{.FieldName}}DataList, Get{{.DataStruct}}Data(id))
	}
	{{end}}
	{{- range .JoinedMapStructs}}
	for k, v := range d.{{.FieldName}} {
		d.{{.FieldName}}DataMap[k] = Get{{.DataStruct}}Data(v)
	}
	{{end}}
	{{- range .GameStructs}}
	if v, err := TryNew{{.DataStruct}}(d.{{.FieldName}}); err != nil {
		panic(errors.WithMessagef(err, "File:%s Id=%d", d.Table(), d.Id()))
	} else {
		d.{{.FieldName}}{{.DataStruct}} = v
  }
	{{end}}
	{{- range .GameStructLists}}
	if v, err := TryNew{{.DataStruct}}List(d.{{.FieldName}}); err != nil {
		panic(errors.WithMessagef(err, "File:%s Id=%d", d.Table(), d.Id()))
	} else {
		d.{{.FieldName}}{{.DataStruct}}List = v
	}
	{{end}}

	{{ if .HasSubData }}
	for _, sd := range d.SubDataList {
		sd.build()
	}
	{{- end }}
}

{{ if .HasSubData }}
func (d *{{.SubDataStruct}}Gen) build() {
	{{- range .JoinedSubStructs}}
	d.{{.FieldName}}Data = Get{{.DataStruct}}Data(d.{{.FieldName}})
	{{end}}
	{{- range .JoinedListSubStructs}}
	for _, id := range d.{{.FieldName}} {
		d.{{.FieldName}}DataList = append(d.{{.FieldName}}DataList, Get{{.DataStruct}}Data(id))
	}
	{{end}}
	{{- range .JoinedMapSubStructs}}
	for k, v := range d.{{.FieldName}} {
		d.{{.FieldName}}DataMap[k] = Get{{.DataStruct}}Data(v)
	}
	{{end}}
	{{- range .SubGameStructs}}
	if v, err := TryNew{{.DataStruct}}(d.{{.FieldName}}); err != nil {
		panic(errors.WithMessagef(err, "File:%s Id=%d", d.Table(), d.Id()))
	} else {
		d.{{.FieldName}}{{.DataStruct}} = v
  }
	{{- end}}
	{{- range .SubGameStructLists}}
	if v, err := TryNew{{.DataStruct}}List(d.{{.FieldName}}); err != nil {
		panic(errors.WithMessagef(err, "File:%s, Id=%d", d.Table(), d.Id()))
	} else {
		d.{{.FieldName}}{{.DataStruct}}List = v
	}
	{{- end}}
}
{{ end }}

func (d *{{.DataStruct}}Gen) init() error {
	return nil
}

`

type DataService struct {
	TablePath     string
	Project       string
	Package       string
	BaseStruct    string
	SubBaseStruct string
	DataStruct    string
	SubDataStruct string

	IsTable    bool
	HasSubData bool
	SubIdField string

	ImportPackages []string

	JoinedStructs     []*ExtraStruct
	JoinedListStructs []*ExtraStruct
	JoinedMapStructs  []*ExtraStruct

	JoinedSubStructs     []*ExtraStruct
	JoinedListSubStructs []*ExtraStruct
	JoinedMapSubStructs  []*ExtraStruct

	GameStructs    []*ExtraStruct
	SubGameStructs []*ExtraStruct

	GameStructLists    []*ExtraStruct
	SubGameStructLists []*ExtraStruct
}

type ExtraStruct struct {
	FieldName  string
	DataStruct string
}

func NewDataService(project string, sh sheet.Sheet) *DataService {
	s := &DataService{
		Project:   project,
		TablePath: sh.GetMetadata().Path + ":" + sh.GetMetadata().Sheet,
		IsTable:   sh.GetMetadata().Type == sheet.SheetTypeTable,
	}
	packageName := sh.GetMetadata().Package
	s.Package = camelcase.ToUnderScore(packageName)

	s.DataStruct = camelcase.ToUpperCamel(sh.GetMetadata().FullName) + "Data"
	s.BaseStruct = camelcase.ToUpperCamel(sh.GetMetadata().Name) + "DataBase"

	if sh.GetSubIdFieldMetadata() != nil {
		s.HasSubData = true
		s.SubDataStruct = camelcase.ToUpperCamel(sh.GetMetadata().FullName) + "SubData"
		s.SubBaseStruct = camelcase.ToUpperCamel(sh.GetMetadata().Name) + "SubDataBase"
		s.SubIdField = camelcase.ToUpperCamel(sh.GetSubIdFieldMetadata().FieldName)
	}

	sh.WalkFieldMetadata(func(md *field.Metadata) error {
		if md.JoinedType == field.JoinedType {
			s.JoinedStructs = append(s.JoinedStructs, &ExtraStruct{
				FieldName:  camelcase.ToUpperCamel(md.FieldName),
				DataStruct: camelcase.ToUpperCamel(md.JoinedName),
			})
		} else if md.JoinedType == field.JoinedListType {
			s.JoinedListStructs = append(s.JoinedListStructs, &ExtraStruct{
				FieldName:  camelcase.ToUpperCamel(md.FieldName),
				DataStruct: camelcase.ToUpperCamel(md.JoinedName),
			})
		} else if md.JoinedType == field.JoinedMapType {
			s.JoinedMapStructs = append(s.JoinedMapStructs, &ExtraStruct{
				FieldName:  camelcase.ToUpperCamel(md.FieldName),
				DataStruct: camelcase.ToUpperCamel(md.JoinedName),
			})
		}
		if md.GameStructName != "" {
			s.GameStructs = append(s.GameStructs, &ExtraStruct{
				FieldName:  camelcase.ToUpperCamel(md.FieldName),
				DataStruct: camelcase.ToUpperCamel(md.GameStructName),
			})
		}
		if md.GameStructListName != "" {
			s.GameStructLists = append(s.GameStructLists, &ExtraStruct{
				FieldName:  camelcase.ToUpperCamel(md.FieldName),
				DataStruct: camelcase.ToUpperCamel(md.GameStructListName),
			})
		}
		return nil
	})

	sh.WalkSubFieldMetadata(func(md *field.Metadata) error {
		if md.JoinedType == field.JoinedType {
			s.JoinedSubStructs = append(s.JoinedSubStructs, &ExtraStruct{
				FieldName:  camelcase.ToUpperCamel(md.FieldName),
				DataStruct: camelcase.ToUpperCamel(md.JoinedName),
			})
		} else if md.JoinedType == field.JoinedListType {
			s.JoinedListSubStructs = append(s.JoinedListSubStructs, &ExtraStruct{
				FieldName:  camelcase.ToUpperCamel(md.FieldName),
				DataStruct: camelcase.ToUpperCamel(md.JoinedName),
			})
		} else if md.JoinedType == field.JoinedMapType {
			s.JoinedMapSubStructs = append(s.JoinedMapSubStructs, &ExtraStruct{
				FieldName:  camelcase.ToUpperCamel(md.FieldName),
				DataStruct: camelcase.ToUpperCamel(md.JoinedName),
			})
		}
		if md.GameStructName != "" {
			s.SubGameStructs = append(s.SubGameStructs, &ExtraStruct{
				FieldName:  camelcase.ToUpperCamel(md.FieldName),
				DataStruct: camelcase.ToUpperCamel(md.GameStructName),
			})
		}
		if md.GameStructListName != "" {
			s.SubGameStructLists = append(s.SubGameStructLists, &ExtraStruct{
				FieldName:  camelcase.ToUpperCamel(md.FieldName),
				DataStruct: camelcase.ToUpperCamel(md.GameStructListName),
			})
		}
		return nil
	})

	return s
}

func (s *DataService) Execute() ([]byte, error) {
	buf := new(bytes.Buffer)

	tmpl, err := template.New("data").Parse(dataTemplate)
	if err != nil {
		return nil, errors.Wrapf(err, "template new data error.")
	}
	if err = tmpl.Execute(buf, s); err != nil {
		return nil, errors.Wrapf(err, "template execute data error.")
	}
	return buf.Bytes(), nil
}
