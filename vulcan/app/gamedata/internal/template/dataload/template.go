package dataload

import (
	"bytes"
	"sort"
	"text/template"

	"github.com/go-pantheon/fabrica-util/camelcase"
	"github.com/go-pantheon/roma/vulcan/app/gamedata/internal/parser/sheet"
)

var dataLoadTemplate = `
{{- /* delete empty line */ -}}
// Code generated by gen-datas. DO NOT EDIT.

package gamedata

import (
	"{{.Project}}/gen/gamedata/base"
)

var (
	{{ range .Structs }}
		{{if .IsTable}}
			{{.LowerCamelStruct}}s *{{.UpperCamelStruct}}s
		{{ else }}
			{{.LowerCamelStruct}} *{{.UpperCamelStruct}}
		{{ end }}
	{{- end }}
)

func loadGen(dir string) {
	var err error

	if err = base.Load(dir); err != nil {
		panic(err)
	}

	{{ range .Structs }}
		{{if .IsTable}}
			{{.LowerCamelStruct}}s, err = new{{.UpperCamelStruct}}s(base.{{.UpperCamelStruct}}BaseGens)
			if err != nil {
				panic(err)
			}
		{{ else }}
			{{.LowerCamelStruct}}, err = new{{.UpperCamelStruct}}(base.{{.UpperCamelStruct}}BaseGen)
			if err != nil {
				panic(err)
			}
		{{ end }}
	{{- end }}

	{{ range .Structs }}
		{{if .IsTable}}
			{{.LowerCamelStruct}}s.build()
		{{ else }}
			{{.LowerCamelStruct}}.build()
		{{ end }}
	{{- end }}

	{{ range .Structs }}
		{{if .IsTable}}
			{{.LowerCamelStruct}}s.init()
		{{ else }}
			{{.LowerCamelStruct}}.init()
		{{ end }}
	{{- end }}
}

{{ range .Structs }}
	{{if .IsTable}}
	func Get{{.UpperCamelStruct}}List() []*{{.UpperCamelStruct}} {
		return {{.LowerCamelStruct}}s.List
	}

	func Get{{.UpperCamelStruct}}(key int64) *{{.UpperCamelStruct}} {
		return {{.LowerCamelStruct}}s.Map[key]
	}
	{{else}}
		func Get{{.UpperCamelStruct}}() *{{.UpperCamelStruct}} {
			return {{.LowerCamelStruct}}
		}
	{{- end }}
{{ end }}
`

type Service struct {
	Project string
	Structs []*StructInfo
}

func NewService(project string, shs []sheet.Sheet) *Service {
	s := &Service{
		Project: project,
		Structs: newStructInfos(shs),
	}
	return s
}

type StructInfo struct {
	UpperCamelStruct string
	LowerCamelStruct string
	Order            int
	IsTable          bool
}

func newStructInfos(shs []sheet.Sheet) structSlice {
	ss := make(structSlice, 0, len(shs))
	for _, sh := range shs {
		ss = append(ss, newStructInfo(sh))
	}
	sort.Sort(ss)
	return ss
}

func newStructInfo(sh sheet.Sheet) *StructInfo {
	s := &StructInfo{
		UpperCamelStruct: camelcase.ToUpperCamel(sh.GetMetadata().FullName) + "Data",
		LowerCamelStruct: camelcase.ToLowerCamel(sh.GetMetadata().FullName) + "Data",
		Order:            sh.GetMetadata().Order,
		IsTable:          sh.GetMetadata().Type == sheet.SheetTypeTable,
	}
	return s
}

func (s *Service) Execute() ([]byte, error) {
	buf := new(bytes.Buffer)

	tmpl, err := template.New("loader").Parse(dataLoadTemplate)
	if err != nil {
		return nil, err
	}
	if err = tmpl.Execute(buf, s); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

type structSlice []*StructInfo

func (x structSlice) Len() int      { return len(x) }
func (x structSlice) Swap(i, j int) { x[i], x[j] = x[j], x[i] }

func (x structSlice) Less(i, j int) bool {
	if x[i].Order < x[j].Order {
		return true
	} else if x[i].Order > x[j].Order {
		return false
	}

	return x[i].UpperCamelStruct < x[j].UpperCamelStruct
}
