package baseload

import (
	"bytes"
	"sort"
	"text/template"

	"github.com/go-pantheon/fabrica-util/camelcase"
	"github.com/go-pantheon/roma/vulcan/app/gamedata/internal/parser"
	"github.com/go-pantheon/roma/vulcan/app/gamedata/internal/parser/sheet"
)

var baseLoadTemplate = `
{{- /* delete empty line */ -}}
// Code generated by gen-data-base. DO NOT EDIT.

package base

{{- $project := .Project}}

import (
	{{- range .Packages }}
	"{{$project}}/gen/gamedata/base/{{.}}"
	{{- end }}

	"path/filepath"
)

var (
	{{- range .TableStructs }}
	{{.UpperPackage}}{{.Struct}} *{{.Package}}.{{.Struct}}
	{{- end }}

	{{ range .KvStructs }}
	{{.UpperPackage}}{{.Struct}} *{{.Package}}.{{.Struct}}
	{{- end }}
)

func Load(dir string) error {
	{{ range .TableStructs }}
	{{.UpperPackage}}{{.Struct}} = {{.Package}}.Load{{.Struct}}(filepath.Join(dir, "{{.JsonFile}}"))
	{{- end }}

	{{ range .KvStructs }}
	{{.UpperPackage}}{{.Struct}} = {{.Package}}.Load{{.Struct}}(filepath.Join(dir, "{{.JsonFile}}"))
	{{- end }}

	return nil
}
`

type Service struct {
	Project      string
	Packages     []string
	TableStructs StructSlice
	KvStructs    StructSlice
}

type Struct struct {
	Package      string
	UpperPackage string
	Name         string
	UpperName    string
	Struct       string

	JsonFile string
}

func NewService(project string, dir *parser.Sheets) *Service {
	s := &Service{
		Project: project,
	}

	packages := make(map[string]struct{})

	dir.Walk(func(gf sheet.Sheet) (continued bool) {
		md := gf.GetMetadata()
		switch md.Type {
		case sheet.SheetTypeTable:
			packages[md.Package] = struct{}{}
			s.TableStructs = append(s.TableStructs, newStruct(gf.GetMetadata(), true))
		case sheet.SheetTypeKV:
			packages[md.Package] = struct{}{}
			s.KvStructs = append(s.KvStructs, newStruct(gf.GetMetadata(), false))
		}
		return true
	})

	for p := range packages {
		s.Packages = append(s.Packages, camelcase.ToUnderScore(p))
	}

	sort.Strings(s.Packages)
	sort.Sort(s.TableStructs)
	sort.Sort(s.KvStructs)

	return s
}

func (s *Service) Execute() ([]byte, error) {
	buf := new(bytes.Buffer)

	tmpl, err := template.New("base_loader").Parse(baseLoadTemplate)
	if err != nil {
		return nil, err
	}

	if err = tmpl.Execute(buf, s); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func newStruct(md *sheet.Metadata, table bool) *Struct {
	s := &Struct{
		Package:      camelcase.ToUnderScore(md.Package),
		UpperPackage: camelcase.ToUpperCamel(md.Package),
		Name:         camelcase.ToLowerCamel(md.Name),
		UpperName:    camelcase.ToUpperCamel(md.Name),
		JsonFile:     md.FullName + ".json",
	}

	s.Struct = s.UpperName + "DataBaseGen"
	if table {
		s.Struct += "s"
	}

	return s
}

type StructSlice []*Struct

func (x StructSlice) Len() int      { return len(x) }
func (x StructSlice) Swap(i, j int) { x[i], x[j] = x[j], x[i] }

func (x StructSlice) Less(i, j int) bool {
	if x[i].Package < x[j].Package {
		return true
	} else if x[i].Package > x[j].Package {
		return false
	}
	return x[i].Struct < x[j].Struct
}
