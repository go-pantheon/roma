package handler

import (
	"bytes"
	"text/template"

	"github.com/vulcan-frame/vulcan-game/vulcan/pkg/compilers"
	"github.com/vulcan-frame/vulcan-util/camelcase"
)

var handlersTemplate = `
{{- /* delete empty line */ -}}
// Code generated by gen-api. DO NOT EDIT.

package handler

import (
	"context"
	"{{.Project}}/game/gen/api/client/module"
	"{{.Project}}/game/gen/app/{{.LowerCamelGroup}}/service"
	"{{.Project}}/fabrica-kit/tunnel"
	"github.com/pkg/errors"
)

func {{.UpperCamelGroup}}Handle(ctx context.Context, s *service.{{.UpperCamelGroup}}Services, in tunnel.ForwardMessage) ([]byte, error) {
	var (
		out []byte
		err error
	)

	switch climod.ModuleID(in.GetMod()) {
	{{ range .Mods }}
	case climod.ModuleID_{{.UpperCamel}}:
		out, err = handle{{.UpperCamel}}(ctx, s, in.GetMod(), in.GetSeq(), in.GetObj(), in.GetData())
	{{- end }}
	default:
		err = errors.Errorf("mod not found. mod=%d", in.GetMod())
	}
	return out, err
}

`

type HandlersService struct {
	Project         string
	UpperCamelGroup string
	LowerCamelGroup string
	Mods            []*Mod
}

type Mod struct {
	UpperCamel string
	LowerCamel string
}

func NewHandlersService(project string, c *compilers.ModsCompiler) *HandlersService {
	s := &HandlersService{
		Project:         project,
		UpperCamelGroup: camelcase.ToUpperCamel(string(c.Group)),
		LowerCamelGroup: camelcase.ToLowerCamel(string(c.Group)),
	}
	for _, mod := range c.Mods {
		s.Mods = append(s.Mods, &Mod{
			LowerCamel: camelcase.ToLowerCamel(string(mod)),
			UpperCamel: camelcase.ToUpperCamel(string(mod)),
		})
	}
	return s
}

func (s *HandlersService) Execute() ([]byte, error) {
	buf := new(bytes.Buffer)

	tmpl, err := template.New("handler").Parse(handlersTemplate)
	if err != nil {
		return nil, err
	}
	if err = tmpl.Execute(buf, s); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
